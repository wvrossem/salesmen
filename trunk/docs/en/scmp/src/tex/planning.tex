\chapter{Configuration Management Planning}

\section{Abbreviations}
In this document a number of abbreviations will be used, which are listed here:
\begin{description}
\item[SCMP]
Software Configuration Management Plan
\item[SCM]
Software Configuration Management
\item[CM]
Configuration Manager
\item[CMA]
Configuration Manager Assistant
\end{description}

\section{Configuration Tree}
This is the structure which will be used to store all source files, reports, webpages and timesheets during the project.
Every team member must be capable of choosing the right directory to commit new files.
If this would not be the case, the CM or the CMA can be contacted to decide where certain new files should be added.
If necessary, this structure can be changed to store a new type of file, but only members of the SCM are authorized to do so, other members are obliged to contact a member of the SCM to request such changes.
For further explanation, see Chapter 2, Change Management.

\subsection{Trunk}
This directory contains three important directories.
\begin{description}
\item[docs]
This is where all documentation about the project is stored.
\item[utils]
Utilities can be found here.
To give an example, Timetrack is a utility which is able to convert .xml-format files to other formats, such as .txt and .html.
This utility is used to convert the timesheets, written in .xml, to .html, so that these can be placed on the website in a readable layout.
\item[www]
The project itself: all source files, website files and libraries must be stored here.
\end{description}

\subsection{Branches}
You can consider the project development as a timeline, in which the trunk is the main branch, but for each stable release, a new branch is added to the timeline.
More information in Chapter 3, Version and Release.

\subsection{Tags}
These are in fact 'snapshots' of the source code at a particular moment in time.
When a stable version is achieved, it can be tagged.
For example, a tag stable0.1 can be made to easily find this particular version.
In other words, a tag is simply an other name for a revision.

\subsection{Timesheets}
Each team member is responsible for his own timesheet, therefor everyone has to be able to write .xml-files, as the timesheets are to be committed in this format.
The deadline for committing timesheets is set each Sunday, 23h59.
To put these timesheets on the website, they are converted into html-format, using Timetrack, see Utilities.
An example of this directory structure is:\\
timesheets/2009/week43/\\
In this directory the timesheets of week 43 of all team members are stored, but only in .xml-format.

\subsection{Minutes}
Of each meeting a report is kept by the secretary, this report is made in LaTeX.
This is saved in the appropriate directory, for each meeting a new directory is made.
An example of this directory structure is:\\
minutes/2009/10/20/\\
This directory contains all necessary formats (.tex, .txt and .pdf) of the report of the meeting that took place on 20 October 2009.
This date is also included in the filename of the report.

\subsection{Wiki}
This is where wikis are stored.
Those wikis can be manuals, agendas or other important documents for team members.
They can easily be edited by every team member, be it via SVN or via Google Code itself.
For example, a Requirements wiki was created to add ideas for requirements.

\section{Tools}
This section is about all the tools that have been chosen to use during the project. Here, tools is to be interpreted as programs, programming languages, servers.

\subsection{Subversion}
Subversion has been chosen to regulate checkouts, commits and updates of project files on the server.
The arguments for this choice are the following:
\begin{description}
\item[Flexibility]
Misplaced adds or files with a badly chosen name, can be changed without problems, which is not the case in, for example, CVS, an older version based server system.
\item[Revisions]
In SVN, commits are saved as revisions.
In this way, all changes made to files are monitored very precisely, because each commit causes an increment of the revision index, which is then given to the new version of the file.
Hence, it is possible to compare revisions.
\item[Centralized]
SVN is created for use with centralized servers, which is ideal for project groups in which everyone knows and can contact everyone.
No team member hosts the main directory, this is done by the central server.
In a {\it decentralized} system the main software is hosted by the manager of the project.
\end{description}

\subsection{Google Code}
Google provides a server which hosts open-source projects and is very interesting to use because it supports the following features:
\begin{description}
\item[Subversion]
The version control system Subversion is standard included when acquiring server space for a project on the Google Code. When activating a server, a few version control systems can be chosen, of which Subversion. This is then installed automatically on the server.
\item[Issues]
An issue system is built in in the website, see more in Chapter 2, Changes.
\item[Wikis]
On the website, team members can write wikis and post them. Very useful for internal documents, such as manuals, agendas, pages for suggestions and information pages.
\item[Website]
All files, changes and revisions on the server can be viewed from any computer with internet connection and a browser. So, there is no need for a working copy to check for changes on the server.
\end{description}

\subsection{Eclipse}
Eclipse is a multi-language software development environment comprising an IDE and a plug-in system to extend it.
It is written primarily in Java and can be used to develop applications in Java and, by means of the various plug-ins, in other languages as well, including C, C++, COBOL, Python, Perl, PHP, and others.
Eclipse is free and open source software, which fits perfectly in this project's purpose.

\subsection{JBoss}
JBoss Application Server (or JBoss AS) is a free software/open-source Java EE-based application server. Because it is Java-based, the JBoss application server operates cross-platform: usable on any operating system that Java supports. This assures great compatibility with Eclipse, which is the reason why this application server was chosen for this project.

\subsection{LaTeX}
LaTeX is a document markup language, which is used for professional purposes, therefor this has been chosen to write all documentation. This document itself is written in LaTeX.

\section{Management Control}
Every team member can checkout and update his working copy of the main software.
To send back changes made to a file of the working copy, one has to commit this file.
When no large changes are made, this should work without problems.
The SCM strongly recommends to work incrementally on files, in other words, committing large changes on different places in a file is not encouraged.
This is to avoid conflicts when trying to merge files edited by different programmers. More about this in the next section, Merging.
If one, for example, wants to implement a new feature, which will drastically change the directory structure, he has to contact the SCM.
The latter will consider this request, but more about this in Chapter 2, Change Management.

\section{Merging}
Imagine two members editing the same file, then committing it to the server at the same time.
This will not be a problem, considering they both worked incrementally on the file, thus not committing a large change at once.
Merging is what regulates this, by recognizing the changes of both sides it can create a new file containing both versions.
It has to be kept in mind that this tool cannot perform miracles.
If two members have worked on the exact same paragraph of a document and then commit, a conflict will occur.
Merging will not provide a solution, but the last one who committed will be asked to clear out this conflict by comparing his version with the conflicting version.

\section{Nightly Build}
In the beginning this will not be dealt with, only once the source code is ready to be compiled and run.
From then on, it will be a daily task to have runnable version of the code, which can be built at the end of the day.
A day cannot be closed if the code is not compiled without errors, otherwise the next day would start with a non-runnable version which needs to be debugged first.
